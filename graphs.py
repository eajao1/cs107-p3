# CMSC 107 -- Student Solution Code
# Fall '18 Haverford College

# 
# EDIT THIS FILE
# I am making a small change to this file.  

# Please refer to `library.py`
from library import *
import doctest 
# -------------------------------------------------------------------
# Warmup: Writing decorator pre / postconditions
#Precondition:
#Postcondition:
# -------------------------------------------------------------------

def myLen(lst):
    precondition(type(lst) == type([]))
    if (lst == []):
        precondition(0 == len(lst))
        return 0
    else:
        postcondition(1 + myLen(lst[1:]) == len(lst))
        return 1 + myLen(lst[1:])

# -------------------------------------------------------------------
# Basic Graph Operations
# -------------------------------------------------------------------

#
# Task 1 / 2

# This is a helper function to help me later on. 
def removeDuplicates(lst):
    #This function recursively  removes the duplicates from a list.
    """
    >>> removeDuplicates([1,2,3,3,4,5,3])
    [1, 2, 4, 5, 3]

    >>> removeDuplicates([1,1,1,1,1])
    [1]

    >>> removeDuplicates([])
    []

    """
    #precondition(forall lst: type(lst) == type([]))
    
    if isEmpty(lst): #if the given list is empty, return an empty list back.
        return []
    else:
        if lst[0] in lst[1:]:                           #otherwise, check if the first element in the list is in the rest of the list.
            return removeDuplicates(lst[1:])            #if it is, call removeDuplicates on the rest of the list.
        else:                                           #if the first element in the list is NOT found in the rest of the list,
            return [lst[0]] + removeDuplicates(lst[1:]) #add this unique element to the list
                                                        #generated by a call to removeDuplicates of the rest of the list. 

# Check whether two given nodes, n1 and n2, in g, are neighbors.
def isNeighbor(g,n1,n2):
    #precondition(for all g: type(g) == type([]))
    
    if isEmpty(g[1]):                       # if the list of egdes in the given graph is empty,
        return False                        #return False because neither nodes has a neighbor.
    else:
        if n1 in g[1][0] and n2 in g[1][0]: #otherwise, if both nodes are in the first list of edges, return True. They are neighbors.
            return True  
        else:                               #if not check that the nodes against the next list of edges. 
            return isNeighbor([g[0],g[1][1:]],n1,n2)
        
#This function returns a list representing the set of immediate neighbors of a given node.
def getNeighbors(g, n):

    #precondition(for all g: type(g) == type([]))
    if isEmpty(g[1]): #If the list of edges is empty, return an empty list. There are no immediate neighbors.
        return []
    else:
        store_lst = getNeighbors([g[0], g[1][1:]],n) #otherwise, create a list to store the set of immediate set neighbors of the rest of the list.
        if n == g[1][0][0]:                          #if the node matches the first element of the first node...
            store_lst.append(g[1][0][1])             #add the corresponding edge to the list. This is its neighbor.
        if n == g[1][0][1]:                          #if the node matches the second element of the first node...
            store_lst.append(g[1][0][0])             #add the corresponding edge to the list. This is its neighbor.
    return removeDuplicates(store_lst)               #return store_lst without duplicates. This accounts for nodes who are neighbors of themselves.e.g (1,1)
   

# -------------------------------------------------------------------
# Graph Color Checking
# -------------------------------------------------------------------

#
# Predicate to test whether the coloring has the right "shape":
# everything in the coloring is a pair with its first element as a
# number, and second element is a string
# 

def looksLikeColorAssignment(colorAsn):
    return len(colorAsn) == 2 and type(colorAsn) == type(1) and type(colorAsn[1]) == type("")

def looksLikeColoring(coloring):
    return forall(coloring, looksLikeColorAssignment)


# Tasks 3, 4, and 5

#This is a set of helper fucntions to help me with tasks 3 and 4.

#This function recursively returns just a list of the colors of a given coloring.
def justColors(coloring):
    precondition(type(coloring) == type([]))
    """
    >>> justColors([(1,"blue"),(2, "pink"), (4,"black")])
    ["blue", "pink", "black"]

    >>> justColors([(1,"blue"),(1, "pink"), (1,"black")])
    ["blue", "pink", "black"]

    >>> justColors([(1,"blue"),(1, "pink"), (1,"black")])
    ["blue", "blue", "blue"]

    >>> justColors([])
    []
    
    """
    if isEmpty(coloring):
        return []                                          #if coloring is empty, return an empty list.
    else:
        return [coloring[0][1]] + justColors(coloring[1:]) #otherwise return a concatenated list of the first color, plus a list
                                                           #generated by justColors on the rest of the list.

#Similarly to justColors, this function returns a list of justNumbers on a given coloring. 
def justNumbers(coloring):

    precondition(type(coloring) == type([]))
    """
    >>> justNumbers([(1,"blue), (2, "pink"), (4,"black")])
    [1,2,4]

    >>> justNumbers([])
    []

    >>> justNumbers([(1, "blue"), (1, "blue")])
    [1,1]
    
    """
    
    if isEmpty(coloring): #if coloring is empty, return an empty list.
        return []
    else:                 #else, return the first number in coloring, and call justNumbers on the rest of coloring.
        return [coloring[0][0]] + justNumbers(coloring[1:])
  
def isIn(lst1, lst2):
    #This function recursively checks that everything in lst1 is in lst 2.

    #precondition(for all lst1: type(lst1) == type([]))
    #precondition(for all lst2: type(lst2) == type([]))

    """
    >>> isIn([],[1,2])
    True

    >>> isIn([],[])
    True

    isIn([1,2], [1,2,3])
    True

    isIn([1,2,3], [1,2])
    False

    """
    if isEmpty(lst1): #if lst1 is empty, return True; everything in lst1 is in lst2
        return True
    else:             #otherwise, return True if the first element in lst 1 is in lst2 AND the rest of lst1 is in the rest of lst2
       return head(lst1) in lst2 and isIn(tail(lst1), tail(lst2)) 

# Task 3
# Return the number of colors used for a given coloring
# Precondition: 'coloring' has to be a list of tuples. The second element in each tuple should be a string object.
# Ideally, that string object should represent a color.

def numColors(coloring):
    if isEmpty(coloring): #if coloring is empty, return 0 since the number of colors in an empty list is 0.
        return 0
    else: 
        y = removeDuplicates(justColors(coloring)) #otherwise remove the duplicates of a list of colors in coloring, store that list in y.
        return len(y)                              #return the length of y

# Task 4
# Check whether a given coloring is consistent for a graph, `g`
# Precondition: 'coloring' must be a tuple consisting of (number, string object). The graph cannot be empty.

def isConsistent(g, coloring):
    #First, check that there is exactly one coloring for each node in the graph.
    #A coloring = ([1,"red"], [1, "blue"]) is inconsistent because there is more than one
    #coloring for each node, but ([1,"red"], [1, "red"]) is consitent.As such, we remove the duplicates from coloring first.

    #This means that if the list of justNumbers() of a coloring that has had the duplicates removed
    #matches a removeDuplicates(list of justNumbers of a removeDuplicates(coloring)), then is passes this consitency test.
    #eg. If coloring = ([1,"red"], [1, "blue"]) it compares [1,1] with [1]. These are not equal.
    
    if justNumbers(removeDuplicates(coloring)) != removeDuplicates(justNumbers(removeDuplicates(coloring))):
        return False #otherwise, return False

    #Then we check that the coloring includes no nodes not in the graph. If it does, return False.
    else:
        if isIn(removeDuplicates(justNumbers(coloring)), g[0]) == False: #if the numbers in coloring are not in the list of nodes in the graph,
            return False                                                 #return False
        else:
            return True                                                  #both consistency tests pass, return True.

# Task 5
# Get the color of an individual node `n`
# precondition(for all coloring, n: len(coloring) >= 1 and looksLikeColoring(coloring))
def getColor(coloring, n):

    if coloring[0][0] == n:             #if the number in the first tuple in coloring matches the given node, return the corresponding color.   
        return coloring[0][1]
    else:
        return getColor(coloring[1:],n) #otherwise, run getColor on the rest of coloring.

# -------------------------------------------------------------------
# END OF P3 / BEGIN P4
# -------------------------------------------------------------------

# Task 6
# Is a coloring `coloring` valid for a graph `g`
# precondition(for all g, coloring: isConsistent(g, coloring))
def isValidColoring(g, coloring):
    raise  UnimplementedExeception

# Check whether `coloring` is a valid k-coloring of `g`
def isValidKColoring(g, coloring, k):
    return isValidColoring(g, coloring) and numColors(coloring) <= k

# -------------------------------------------------------------------
# Sets
# -------------------------------------------------------------------

#
# Set operations on lists
# 

# Check whether `e` is a member of `lst`
def member(lst, e): 
    return forall(lst, lambda x: x != e)

# Check that `lst` has no duplicate elements
#precondition(for all lst: type(lst) == type([]))
def noRepeats(lst): 
    if isEmpty(lst): return True
    else: return (not member(tail(lst), head(lst)) and noRepeats(tail(lst)))

# Take the union of two lists, regarded as sets
def setUnion(lst1, lst2):
    if (isEmpty(lst1)): return lst2
    elif (member(head(lst1), lst2)):
        return setUnion(tail(lst1), lst2)
    else:
        return [head(lst1)] + setUnion(tail(lst1), lst2)

# Calculate the intersection of two sets, lst1 and lst2
def setIntersection(lst1, lst2):
    if (isEmpty(lst1)): return lst2
    elif (member(head(lst1), lst2)):
        return [head(lst1)] + setUnion(tail(lst1), lst2)
    else:
        return setUnion(tail(lst1), lst2)

# Task 7
# Calculate whether or not two sets, `lst1` and `lst2`, are equal or
# not.
def setEquals(lst1, lst2):
    if len(lst1) != len(lst2):
        return False
    if isEmpty(lst1) and isEmpty(lst2):
        return True
    else:
        return head(lst1) in lst2 and setEquals(tail(lst1),tail(lst2))

# -------------------------------------------------------------------
# Bipartite checking
# -------------------------------------------------------------------

# Task 8
#
# Take one "step" of the frontier. This is explained in the readme,
# but basically the idea here is to take all of the neighbors from
# every element in set A, and union them with the set B
# 
# I invite you to write a more precise precondition that states this
# mathematically
def calculateNextSet(g,A,B):
    raise UnimplementedExeception

# Using `calculateNextSet`, iterate the sets A and B until no more
# exploration is possible: at each step of the way, find A's neighbors
# and add them to B (using `calculateNextSet`), and then swap B with A
# to continue the exploration
def iterateFrontier(A,B):
    if (setEquals(calculateNextSet(A,B), B)):
        # Done, no work to be done
        return (A,B)
    else:
        return iterateFrontier(calculateNextSet(A,B), A)

# Pick an artbirary node in the graph to put in set `A`, and leave set
# `B` empty
def start(graph):
    return (graph[0][0], [])

# Check whether or not a graph is bipartite, using the other functions
# defined so far
def calculateBipartite(graph):
    # Calculate the final sets A and B as a pair
    answer = iterateFrontier(start(graph))
    A = answer[0]
    B = answer[1]
    return isEmpty(setIntersection(A,B))
